// npm start demo1 - start app

var args = process.argv.slice(2);
config = args[0];
run_mode = args[1];
require("../config/" + config); //global config -> conf
require('dotenv').config();
const firebase = require('../libs/firebase_db');
const fdb = firebase.fdb;
const fauth = firebase.fauth;
const express = require('express');
const request = require('request')
var app = require("../app");
var http = require("http");
var https = require('https');
var fs = require("fs");
let port = conf.port || process.env.PORT;

run_mode = args[1];



var server = http.createServer(app);
server.listen(conf.port);
server.on("error", onError);






generateSK = () => {
  var sk = crypto.randomBytes(20).toString("hex");
  return sk;
}

generatePassword = () => {
  var randomstring = Math.random().toString(36).slice(-6);
  return randomstring;
}

getCookie = (name) => {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return parts.pop().split(';').shift();
}

getCurrentDate = () => {
  var currentDate = new Date();

  var day = currentDate.getDate().toString().padStart(2, '0');
  var month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
  var year = currentDate.getFullYear();

  var hours = currentDate.getHours().toString().padStart(2, '0');
  var minutes = currentDate.getMinutes().toString().padStart(2, '0');

  var date = `${day}.${month}.${year} ${hours}:${minutes}`;
  return date;
}

function onError(error) {
  if (error.syscall !== "listen") {
    throw error;
  }

  var bind = typeof port === "string" ? "Pipe " + port : "Port " + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case "EACCES":
      console.error(bind + " requires elevated privileges");
      //process.exit(1);
      break;
    case "EADDRINUSE":
      console.error(bind + " is already in use");
      //process.exit(1);
      break;
    default:
      throw error;
  }
}

getAdminInfo = async function (panel_id, user_id, callback) {
  const user = await fdb.collection('panels').doc(panel_id).collection('users').doc(user_id).get();

  if (user.data().role != 'admin') {
    return callback({ 'r': 0 })
  }

  return callback({
    'id': user.data().user_id,
    'first_name': user.data().first_name,
    'last_name': user.data().last_name,
    'email': user.data().email,
    'email': user.data().email,
    'r': 1,
  });
}

encode = function (str, shift) {
  return str.split('').map(char => {
    if (char.match(/[a-z]/i)) {
      const code = char.charCodeAt(0);
      const isUpperCase = code >= 65 && code <= 90;
      const base = isUpperCase ? 65 : 97;
      return String.fromCharCode(((code - base + shift) % 26) + base);
    }
    return char;
  }).join('');
}

decode = function (str, shift) {
  return encode(str, 26 - shift);
}

requestAIWriting = function(text, title) {
    return new Promise((resolve, reject) => {
        var json_structure = `
        {
          grade: '',
          feedback: '',
          improvements: {
            task_achievement: ['sentence1', 'sentence2', ...],
            coherence : ['sentence1', 'sentence2', 'example1', ...],
            lexical_resource: ['sentence1', 'sentence2', 'example1', ...],
            grammatical_range_accuracy : ['sentence1', 'sentence2', 'example1', ...],

          }
        }
        `
        var options = {
            method: 'POST',
            url: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=' + process.env.GEMINI_API_KEY,
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                "contents": [
                    {
                        "parts": [
                          {
                            "text": `Please provide a assessment of the following text for IELTS writing and give detailed feedback:
                            * Use the specified JSON structure: ${json_structure}.
                            * Title of the essay: "${title}". Text must be related to title, if not band 1.
                            * Text: "${text}".
                            * Ensure the feedback covers the four IELTS criteria: Task Achievement, Coherence and Cohesion, Lexical Resource, and Grammatical Range and Accuracy.
                            * Provide a numeric IELTS score for each of the four criteria, and an overall score.
                            * Do not use markdown formatting.
                            * Feedback should be in English and comprehensive, highlighting both strengths and areas for improvement.
                            `
                          }
                        ]
                    }
                ]
            })
        };

        function validateJson(data) {
            try {
                JSON.parse(data);
                return true;
            } catch (e) {
                return false;
            }
        }

        function handleResponse(error, response) {
            if (error) {
                reject(error);
            } else {
                let jsonData;
                try {
                  console.log(response)
                    var resp = JSON.parse(response.body)
                    
                    var scenario_json = resp.candidates[0].content.parts[0].text
                    let jsonData = scenario_json.replace(/json/g, '').replace(/```/g, '');

                    console.log(jsonData)
                    if (validateJson(jsonData)) {
                        resolve(jsonData);
                    } else {
                        console.log("Invalid JSON, retrying...");
                        requestAIWriting(text, title).then(resolve).catch(reject);
                    }
                } catch (parseError) {
                    reject(parseError);
                }
            }
        }

        request(options, handleResponse);
    });
}

requestAISpeaking = function(text, question) {
  return new Promise((resolve, reject) => {
      var json_structure = `
      {
        grade: '',
        feedback: '',
        improvement: 'example'
      }
      `
      var options = {
          method: 'POST',
          url: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=' + process.env.GEMINI_API_KEY,
          headers: {
              'Content-Type': 'application/json'
          },
          body: JSON.stringify({
              "contents": [
                  {
                      "parts": [
                        {
                          "text": `Please provide a assessment of the following text for speaking:
                          * Use the specified JSON structure: ${json_structure}.
                          * Title of the essay: "${question}". Text must be related to title, if not band 1.
                          * Text: "${text}".
                          * Do not use markdown formatting.
                          * Feedback should be in Russian and comprehensive, highlighting both strengths and areas for improvement.
                          `
                        }
                      ]
                  }
              ]
          })
      };

      function validateJson(data) {
          try {
              JSON.parse(data);
              return true;
          } catch (e) {
              return false;
          }
      }

      function handleResponse(error, response) {
          if (error) {
              reject(error);
          } else {
              let jsonData;
              try {
                console.log(response)
                  var resp = JSON.parse(response.body)
                  
                  var scenario_json = resp.candidates[0].content.parts[0].text
                  let jsonData = scenario_json.replace(/json/g, '').replace(/```/g, '');

                  console.log(jsonData)
                  if (validateJson(jsonData)) {
                      resolve(jsonData);
                  } else {
                      console.log("Invalid JSON, retrying...");
                      requestAIWriting(text, title).then(resolve).catch(reject);
                  }
              } catch (parseError) {
                  reject(parseError);
              }
          }
      }

      request(options, handleResponse);
  });
}


requestAITitle = function() {
  return new Promise((resolve, reject) => {
      var json_structure = `
      {
        title: 'title'
      }
      `
      var options = {
          method: 'POST',
          url: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=' + process.env.GEMINI_API_KEY,
          headers: {
              'Content-Type': 'application/json'
          },
          body: JSON.stringify({
              "contents": [
                  {
                      "parts": [
                        {
                          "text": `Make up a random title for IELTS Writing Exam
                          * Output in json structure: ${json_structure}
                          `
                        }
                      ]
                  }
              ]
          })
      };

      function validateJson(data) {
          try {
              JSON.parse(data);
              return true;
          } catch (e) {
              return false;
          }
      }

      function handleResponse(error, response) {
          if (error) {
              reject(error);
          } else {
              let jsonData;
              try {
                console.log(response)
                  var resp = JSON.parse(response.body)
                  
                  var scenario_json = resp.candidates[0].content.parts[0].text
                  let jsonData = scenario_json.replace(/json/g, '').replace(/```/g, '');

                  console.log(jsonData)
                  if (validateJson(jsonData)) {
                      resolve(jsonData);
                  } else {
                      console.log("Invalid JSON, retrying...");
                      requestAITitle().then(resolve).catch(reject);
                  }
              } catch (parseError) {
                  reject(parseError);
              }
          }
      }

      request(options, handleResponse);
  });
}

requestAITFNG = function(difficulty){
  return new Promise((resolve, reject) => {
    var json_structure = `
    {
      text: 'Reading Text',
      title: 'Title',
      questions: [{question: "Question", answer: "true/false/not_given"}, ...]
    }
    `
    var options = {
        method: 'POST',
        url: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=' + process.env.GEMINI_API_KEY,
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            "contents": [
                {
                    "parts": [
                      {
                        "text": `Make up a random "True/False/Not given" Reading Section Exam
                        * Output in json structure: ${json_structure}
                        * Difficulty: ${difficulty}
                        * only 6 questions
                        * more than 150 words
                        `
                      }
                    ]
                }
            ]
        })
    };

    function validateJson(data) {
        try {
            JSON.parse(data);
            return true;
        } catch (e) {
            return false;
        }
    }

    function handleResponse(error, response) {
        if (error) {
            reject(error);
        } else {
            let jsonData;
            try {
              console.log(response)
                var resp = JSON.parse(response.body)
                
                var scenario_json = resp.candidates[0].content.parts[0].text
                let jsonData = scenario_json.replace(/json/g, '').replace(/```/g, '');

                console.log(jsonData)
                if (validateJson(jsonData)) {
                    resolve(jsonData);
                } else {
                    console.log("Invalid JSON, retrying...");
                    requestAITFNG(difficulty).then(resolve).catch(reject);
                }
            } catch (parseError) {
                reject(parseError);
            }
        }
    }

    request(options, handleResponse);
});
}


requestAIQuestion= function() {
  return new Promise((resolve, reject) => {
      var json_structure = `
      {
        question: 'question'
      }
      `
      var options = {
          method: 'POST',
          url: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=' + process.env.GEMINI_API_KEY,
          headers: {
              'Content-Type': 'application/json'
          },
          body: JSON.stringify({
              "contents": [
                  {
                      "parts": [
                        {
                          "text": `Generate a question to check speaking skills of user
                          * Open question
                          * Output in json structure: ${json_structure}
                          `
                        }
                      ]
                  }
              ]
          })
      };

      function validateJson(data) {
          try {
              JSON.parse(data);
              return true;
          } catch (e) {
              return false;
          }
      }

      function handleResponse(error, response) {
          if (error) {
              reject(error);
          } else {
              let jsonData;
              try {
                console.log(response)
                  var resp = JSON.parse(response.body)
                  
                  var scenario_json = resp.candidates[0].content.parts[0].text
                  let jsonData = scenario_json.replace(/json/g, '').replace(/```/g, '');

                  console.log(jsonData)
                  if (validateJson(jsonData)) {
                      resolve(jsonData);
                  } else {
                      console.log("Invalid JSON, retrying...");
                      requestAITitle().then(resolve).catch(reject);
                  }
              } catch (parseError) {
                  reject(parseError);
              }
          }
      }

      request(options, handleResponse);
  });
}